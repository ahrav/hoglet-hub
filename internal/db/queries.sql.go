// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOperation = `-- name: CreateOperation :one

INSERT INTO operations (
    tenant_id,
    operation_type,
    status,
    parameters,
    created_by
) VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateOperationParams struct {
	TenantID      pgtype.Int8
	OperationType string
	Status        OperationStatus
	Parameters    []byte
	CreatedBy     string
}

// Operation Queries
func (q *Queries) CreateOperation(ctx context.Context, arg CreateOperationParams) (int64, error) {
	row := q.db.QueryRow(ctx, createOperation,
		arg.TenantID,
		arg.OperationType,
		arg.Status,
		arg.Parameters,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTenant = `-- name: CreateTenant :one

INSERT INTO tenants (
    name,
    region,
    status,
    tier,
    is_isolated,
    isolation_group_id,
    created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateTenantParams struct {
	Name             string
	Region           RegionType
	Status           TenantStatus
	Tier             string
	IsIsolated       pgtype.Bool
	IsolationGroupID pgtype.Int8
	CreatedBy        string
}

// Tenant Queries
func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTenant,
		arg.Name,
		arg.Region,
		arg.Status,
		arg.Tier,
		arg.IsIsolated,
		arg.IsolationGroupID,
		arg.CreatedBy,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTenant = `-- name: DeleteTenant :exec
UPDATE tenants
SET
    status = 'deleted',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteTenant(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTenant, id)
	return err
}

const findIncompleteOperations = `-- name: FindIncompleteOperations :many
SELECT id, tenant_id, operation_type, status, parameters, result, error_message, created_at, updated_at, started_at, completed_at, created_by FROM operations
WHERE status IN ('pending', 'in_progress')
ORDER BY created_at ASC
`

func (q *Queries) FindIncompleteOperations(ctx context.Context) ([]Operation, error) {
	rows, err := q.db.Query(ctx, findIncompleteOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OperationType,
			&i.Status,
			&i.Parameters,
			&i.Result,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOperationByID = `-- name: FindOperationByID :one
SELECT id, tenant_id, operation_type, status, parameters, result, error_message, created_at, updated_at, started_at, completed_at, created_by FROM operations
WHERE id = $1
LIMIT 1
`

func (q *Queries) FindOperationByID(ctx context.Context, id int64) (Operation, error) {
	row := q.db.QueryRow(ctx, findOperationByID, id)
	var i Operation
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OperationType,
		&i.Status,
		&i.Parameters,
		&i.Result,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
	)
	return i, err
}

const findOperationsByStatus = `-- name: FindOperationsByStatus :many
SELECT id, tenant_id, operation_type, status, parameters, result, error_message, created_at, updated_at, started_at, completed_at, created_by FROM operations
WHERE status = $1
ORDER BY created_at ASC
`

func (q *Queries) FindOperationsByStatus(ctx context.Context, status OperationStatus) ([]Operation, error) {
	rows, err := q.db.Query(ctx, findOperationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OperationType,
			&i.Status,
			&i.Parameters,
			&i.Result,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOperationsByTenantID = `-- name: FindOperationsByTenantID :many
SELECT id, tenant_id, operation_type, status, parameters, result, error_message, created_at, updated_at, started_at, completed_at, created_by FROM operations
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindOperationsByTenantID(ctx context.Context, tenantID pgtype.Int8) ([]Operation, error) {
	rows, err := q.db.Query(ctx, findOperationsByTenantID, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OperationType,
			&i.Status,
			&i.Parameters,
			&i.Result,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTenantByID = `-- name: FindTenantByID :one
SELECT id, name, region, status, tier, database_schema, is_isolated, gke_cluster_name, kubernetes_namespace, isolation_group_id, primary_node_id, created_at, updated_at, created_by FROM tenants
WHERE id = $1 AND status != 'deleted'
LIMIT 1
`

func (q *Queries) FindTenantByID(ctx context.Context, id int64) (Tenant, error) {
	row := q.db.QueryRow(ctx, findTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Region,
		&i.Status,
		&i.Tier,
		&i.DatabaseSchema,
		&i.IsIsolated,
		&i.GkeClusterName,
		&i.KubernetesNamespace,
		&i.IsolationGroupID,
		&i.PrimaryNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const findTenantByName = `-- name: FindTenantByName :one
SELECT id, name, region, status, tier, database_schema, is_isolated, gke_cluster_name, kubernetes_namespace, isolation_group_id, primary_node_id, created_at, updated_at, created_by FROM tenants
WHERE name = $1 AND status != 'deleted'
LIMIT 1
`

func (q *Queries) FindTenantByName(ctx context.Context, name string) (Tenant, error) {
	row := q.db.QueryRow(ctx, findTenantByName, name)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Region,
		&i.Status,
		&i.Tier,
		&i.DatabaseSchema,
		&i.IsIsolated,
		&i.GkeClusterName,
		&i.KubernetesNamespace,
		&i.IsolationGroupID,
		&i.PrimaryNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const updateOperation = `-- name: UpdateOperation :exec
UPDATE operations
SET
    status = $2,
    result = $3,
    error_message = $4,
    started_at = $5,
    completed_at = $6,
    updated_at = NOW()
WHERE id = $1
`

type UpdateOperationParams struct {
	ID           int64
	Status       OperationStatus
	Result       []byte
	ErrorMessage pgtype.Text
	StartedAt    pgtype.Timestamptz
	CompletedAt  pgtype.Timestamptz
}

func (q *Queries) UpdateOperation(ctx context.Context, arg UpdateOperationParams) error {
	_, err := q.db.Exec(ctx, updateOperation,
		arg.ID,
		arg.Status,
		arg.Result,
		arg.ErrorMessage,
		arg.StartedAt,
		arg.CompletedAt,
	)
	return err
}

const updateTenant = `-- name: UpdateTenant :exec
UPDATE tenants
SET
    status = $2,
    tier = $3,
    is_isolated = $4,
    isolation_group_id = $5,
    database_schema = $6,
    kubernetes_namespace = $7,
    primary_node_id = $8,
    updated_at = NOW()
WHERE id = $1
`

type UpdateTenantParams struct {
	ID                  int64
	Status              TenantStatus
	Tier                string
	IsIsolated          pgtype.Bool
	IsolationGroupID    pgtype.Int8
	DatabaseSchema      pgtype.Text
	KubernetesNamespace pgtype.Text
	PrimaryNodeID       pgtype.Int8
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) error {
	_, err := q.db.Exec(ctx, updateTenant,
		arg.ID,
		arg.Status,
		arg.Tier,
		arg.IsIsolated,
		arg.IsolationGroupID,
		arg.DatabaseSchema,
		arg.KubernetesNamespace,
		arg.PrimaryNodeID,
	)
	return err
}
